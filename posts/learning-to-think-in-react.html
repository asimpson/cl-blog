<p>Some of you may have noticed that this blog has been going through some renovations. I’ve spent the last couple months moving off <a href="http://siteleaf.com/">Siteleaf</a> and towards a hosted WordPress install. My ultimate goal is to use Wordpress strictly for managing content and to attach a separate front-end written in React.js. While not completely finished, I’m at the point where all pieces are functional enough that I feel comfortable to begin sharing what I’ve learned through the process.</p>

<h2>React</h2>

<p>At the moment, React is definitely the cool kid on the Javascript framework block, which history tells us is a perilous and passing position. Regardless, I’ve been intrigued by its philosophy and decisions for a while. Love Facebook or hate them, you can’t deny they have a <a href="https://code.facebook.com/">fantastic engineering team</a> solving some of the hardest problems on the web. My interest in React stems from the fact that that, instead of setting out to solve all the problems of building a web app, it aims to solve just one: the complexity of building user-interfaces. Facebook explains how React makes building UIs easier in <a href="https://facebook.github.io/react/blog/2013/11/05/thinking-in-react.html">a perfect introductory post</a> (which I’ve gone back to many times) that walks through building up a frontend from scratch. Because React is focused on the user interface, it isn’t a very large API to learn. This focus encourages you to use any other tooling, frameworks, or libraries for other aspects of your app.</p>

<h2>Isomorphic</h2>

<p>React’s other big draw for me is that it easily enables an isomorphic structure for your web application, which simply means that the same code can render HTML pages on the server and render HTML in the browser. React accomplishes this via two render methods: <code>render</code> and <code>renderToString</code>. <code>render</code> is the default method that inserts the React HTML into a DOM node, and <code>renderToString</code> does what it says on the tin by passing the HTML out as a string.</p>

<p>The biggest challenge has been learning to think "isomorphically." Thankfully, there are several fantastic articles that walk through how to structure and reason about an isomorphic app. <a href="http://nicolashery.com/exploring-isomorphic-javascript/">Nicolas Hery has a fantastic overview</a> of what an isomorphic app structure can and <em>should</em> look like; I still have this one open in my browser, as I refer to it constantly. I was inspired by <a href="http://jlongster.com/Presenting-The-Most-Over-Engineered-Blog-Ever">James Long’s excellent post</a> on moving his blog to React. Additionally, <a href="http://www.crmarsh.com/react-ssr/">Charlie Marsh’s post</a> helped me get off the ground when it comes to writing an isomorphic app with React.</p>

<h2>Data flow</h2>

<p>Having an isomorphic app means data flow in the app is going to change, and I definitely bent my brain trying to figure out a reasonable approach. The <a href="http://nicolashery.com/exploring-isomorphic-javascript/">aforementioned Hery article</a> does a great job of outlining one possible solution. Facebook of course has its Flux architecture as the "preferred" approach, but I opted for a simpler approach more akin to <a href="http://jlongster.com/Presenting-The-Most-Over-Engineered-Blog-Ever">James</a>’ flow. Essentially, I defined a <a href="https://facebook.github.io/react/docs/component-specs.html#statics">static function</a> called <code>fetchData</code> anywhere I needed to request data. I then called this function on the router level.</p>

<h2>React-router</h2>

<p>Speaking of the router, I’m using the awesome and delightful <a href="https://github.com/rackt/react-router">React-router</a>. React-router is a fantastic example of how to maintain an open-source project. <a href="https://github.com/rackt/react-router/wiki/Announcements#whats-the-deal-with-the-new-api">This post announcing changes to its API</a> reveal the depth of thinking and intentionality of React-router’s authors. I’ve poured over the docs and issues in the course of this project and have been impressed with it constantly.</p>

<p>I’m using React-router to handle routes on the server and the client (yay, isomorphic!) with React’s <code>render</code> and <code>renderToString</code> methods. This means that I have a <code>server-routes.js</code> file and a <code>client-routes.js</code> file, which are the only two files that <em>aren’t</em> shared between the client and the server. I’m using a vanilla Express server to kickoff the server portion of the blog. React-router simply plugs in as middleware to handle serving up the application. On the client, I have React-router using the History APIs to navigate, which greatly increases the perceived performance of the site.</p>

<h2>Promises</h2>

<p>This was my first experience working with Promises in Javascript. I don’t know how I could have done this project without them - I’d probably still be untangling all the callbacks. Luckily, the brilliant minds behind <a href="http://cujojs.com/">CujoJS</a> have not only a <a href="https://github.com/cujojs/when">great promises library</a>, but also a <a href="https://github.com/cujojs/rest">rest library that returns promises</a>. Moreover, both libraries work in the browser and on the server. The pattern I followed for my data fetching looks like this:</p>

<pre><code class="language-javascript">
var promises = state.routes.filter(function (route) {
  return route.handler.fetchData;
}).reduce(function (promises, route) {
  promises[route.name] = route.handler.fetchData(state.params);
  return promises;
}, {});

resolveHash(promises).then(function (data) {
  React.render(&lt;Handler data={data}/>, container);
});
</code>
</pre>

<p>Sidenote: For a fantastic primer on <code>.map</code>, <code>.reduce</code>, and <code>.filter</code>, check out <a href="http://www.elijahmanor.com/reducing-filter-and-map-down-to-reduce/">Elijah Manor’s post</a>.</p>

<p>These functions go in <a href="https://github.com/rackt/react-router/blob/master/docs/api/run.md">react-router’s run callback</a>. The <code>state.routes</code> object contains the matching route components, so you can filter over them and get all the necessary <code>fetchData</code> functions. We massage this object of functions into a key:value structure to use with the <code>resolveHash</code> method that ships with <a href="https://github.com/cujojs/when">whenjs</a>. <code>resolveHash</code> will call all the <code>fetchData</code> methods, and once all data has been fetched it calls back to React to render with the new data. This is all possible because, thanks to <a href="https://github.com/cujojs/rest">rest</a>, every <code>fetchData</code> method returns a promise. Here is an example of what a <code>fetchData</code> function looks like:</p>

<pre><code class="language-javascript">
fetchData: function(pageNumber) {
  var fetchPosts = rest(url).then(function(response) {
    var postInfo = {
    };
    return postInfo;
  });
  return fetchPosts;
}
</code>
</pre>

<h2>Going Forward</h2>

<p>I think that covers the React portion for now. I've pulled the React portion out of my private repo and <a href="https://github.com/asimpson/react-blog">published it on Github</a>, feel free to browse around. I hope to outline other interesting pieces of the blog, including the WordPress side of things, soon. Feel free to ping me on <a href="http://twitter.com/a_simpson">twitter</a> with any questions.</p>
